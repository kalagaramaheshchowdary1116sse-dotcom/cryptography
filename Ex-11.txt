import numpy as np

def mod_inverse_matrix(matrix, m=26):
    det = int(np.round(np.linalg.det(matrix)))
    det = det % m
    inv_det = pow(det, -1, m)
    matrix_adj = np.round(det * np.linalg.inv(matrix)).astype(int) % m
    return (inv_det * matrix_adj) % m

def text_to_numbers(text):
    return [ord(c) - 65 for c in text.upper() if c.isalpha()]

def numbers_to_text(nums):
    return ''.join(chr(int(n) + 65) for n in nums)

def hill_encrypt(plaintext, key_matrix):
    nums = text_to_numbers(plaintext)
    if len(nums) % 2 != 0:
        nums.append(ord('X') - 65)
    nums = np.array(nums).reshape(-1, 2).T
    cipher_nums = (key_matrix @ nums) % 26
    return numbers_to_text(cipher_nums.T.flatten())

def hill_decrypt(ciphertext, key_matrix):
    nums = text_to_numbers(ciphertext)
    nums = np.array(nums).reshape(-1, 2).T
    inv_matrix = mod_inverse_matrix(key_matrix)
    plain_nums = (inv_matrix @ nums) % 26
    return numbers_to_text(plain_nums.T.flatten())

key_matrix = np.array([[9,4],[5,7]])
msg = input("Enter message: ")
enc = hill_encrypt(msg, key_matrix)
print("Encrypted:", enc)
print("Decrypted:", hill_decrypt(enc, key_matrix))

